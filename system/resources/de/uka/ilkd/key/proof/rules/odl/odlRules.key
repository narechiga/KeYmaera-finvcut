// This file is part of KeY - Integrated Deductive Software Design
// Copyright (C) 2001-2003 Universitaet Karlsruhe Germany
//                         and Chalmers University of Technology, Sweden          
//
// The KeY system is protected by the GNU General Public License. 
// See LICENSE.TXT for details.
//
// This file contains rules for handling ODL programs


//include "propRule.key";

\sorts{
  \generic G;
  \generic H;
}

\schemaVariables {
 \modalOperator {diamond, box} #allmodal;
 \modalOperator {diamond, box} #normalassign;
 \modalOperator {box} #allpartial;
 \modalOperator {diamond} #alltotal;
 \formula post, inv, post1;
 \program Type #t, #t2 ;
 \program NonPrimitiveType #npit ;  
 \program InstanceCreation #n ;
 \program ArrayCreation #na ;
 \program ArrayInitializer #arrayinitializer ;
 \program makeTransientBooleanArray #tboolarray ;
 \program makeTransientShortArray #tshortarray ;
 \program makeTransientByteArray #tbytearray ;
 \program makeTransientObjectArray #tobjectarray ;
 \program isTransient #istransient ;
 \program ArrayLength #length ;
 \program ImplicitNext #next ;
 \program ImplicitReferenceField #implicitReference, #implicitReference1, #implicitReference2 ;

 \program MultipleVariableDeclaration #multvardecl ;
 \program SimpleExpression #se, #se0, #se1 ;

 \program LeftHandSide #lhs, #lhs0, #lhs1 ;
 \program Variable #loc ;
 \program StaticVariable #sv, #sv0, #sv1 ;

 \program Variable #v, #v0, #v1, #v2, #boolv, #k, #a, #a0, #a1 ;

 \program ImplicitClassInitialized #classInitialized ;
 \program ImplicitClassErroneous #classErroneous ;
 \program ImplicitClassPrepared #classPrepared ;
 \program ImplicitClassInitializationInProgress #classInitializationInProgress ;

 \program ExplicitVariable #ea ;   // not starting with <
 \program ImplicitVariable #ia ;   // starting with <
 \program ConstantVariable #cv ;   // variables that are compile-time constants
 \program Variable #b0, #ar1 ;
 \program VariableInitializer #vi ;
 \program SimpleExpression #seBool,#seBool0,#seBool1,#seBool2 ;
 \program JavaBooleanExpression #exBool,#exBool0,#exBool1,#exBool2 ;

 \program NonSimpleExpression #nseBool,#nseBool0,#nseBool1,#nseBool2 ;
 \program Statement #s, #s0, #s1 ;
 \program LoopInit #loopInit ;
 \program Guard #guard ;
 \program ForUpdates #forupdates ;
 \program Expression #e, #e0, #e1, #e2 ;
 \program NonSimpleExpression #nse, #nse0, #nse1, #nse2, #nv ;

 \program[list] Statement #slist, #slist1, #slist2, #slist3 ;
 \program[list] Expression #elist ;
 \program[list] SimpleExpression #selist ;
 \program[list] Catch #cs ;

 \program Switch #sw ;
 \program Label #lb, #lb0, #lb1 ;
 \program MethodReference #mr ;
 \program NonSimpleMethodReference #nsmr ;

 \program ExecutionContext #ex ; 
 // required for object creation
 \program SpecialConstructorReference #scr ;

 // \generic sorts
 \term H obj ;
 \variables G x ;
}

\functions{
}

\predicates{
}


\rules(programRules:ODL) {

  empty_modality { \find (\modality{#allmodal}{}\endmodality(post)) \replacewith(post) \heuristics(simplify_prog)};

///  eval_return { \find (\modality{#allmodal}{.. return #e; ...}\endmodality(post)) 
///	        varcond(typeof(#e) #v0 new) 	
///		\replacewith(\modality{#allmodal}{.. #typeof(#e) #v0=#e; return #v0; ...}\endmodality(post)) }; 
///
///  eval_return_not_simple { \find (\modality{#allmodal}{.. return #nse; ...}\endmodality(post)) 
///       varcond(typeof(#nse) #v0 new) 	
///       \replacewith(\modality{#allmodal}{.. #typeof(#nse) #v0=#nse; return #v0; ...}\endmodality(post)) 
///       \heuristics(simplify_prog)
///       \displayname "eval_return"}; 

//-----------------------------------------------------------------------------------------
//                        some common assignment rules 
//-----------------------------------------------------------------------------------------

/// assignment       { \find (\modality{#allmodal}{.. #loc = #se; ...}\endmodality(post)) 
///                   \replacewith ({#loc:= #se}\modality{#allmodal}{.. ...}\endmodality(post)) 
///	           \heuristics(simplify_prog, simplify_prog_subset)
///                   \displayname "assignment"};

/// assignment       { \find (\modality{#allmodal}{.. #lhs = #e1; ...}\endmodality(post)) 
///                   \replacewith ({#lhs:= #e1}\modality{#allmodal}{.. ...}\endmodality(post)) 
///	           \heuristics(simplify_prog, simplify_prog_subset)
///                   \displayname "assignment"};

 // would like to combine both rules with #e0 instead of #nse resp. #se Bug #0358
 assignment1       { \find (\modality{#allmodal}{.. #nse = #e; ...}\endmodality(post)) 
                   \replacewith ({#nse:= #e}\modality{#allmodal}{.. ...}\endmodality(post)) 
	           \heuristics(simplify_prog, simplify_prog_subset)
                   \displayname "assignment"};

 assignment2       { \find (\modality{#allmodal}{.. #se = #e; ...}\endmodality(post)) 
                   \replacewith ({#se:= #e}\modality{#allmodal}{.. ...}\endmodality(post)) 
	           \heuristics(simplify_prog, simplify_prog_subset)
                   \displayname "assignment"};

//--------------- variable declarations --------------------------------------//

// local_variable_rename   { \find (\<{.. {#t #v0; #s} ...}\>post) 
//              varcond (#v1 new)
//              \replacewith( {#v1 #v0}\<{.. {#v0 #v1}{#s} ...}\>post) };

  //reviewed 04/19/2004, St.S.
  eliminate_variable_declaration { \find (\modality{#allmodal}{.. #npit #v0; ...}\endmodality(post)) 
		                   \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
                                   \addprogvars(#v0) 
                                   \heuristics(simplify_prog, simplify_prog_subset)
                \displayname "eliminate_variable_declaration"
  };

  //reviewed 04/19/2004, St.S.
  eliminate_variable_declaration_boolean { \find (\modality{#allmodal}{.. boolean #v0; ...}\endmodality(post)) 
		                   \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
                                   \addprogvars(#v0) 
                                   \heuristics(simplify_prog, simplify_prog_subset)
                \displayname "eliminate_variable_declaration"
  };


// ATTENTION - may not be right for \throughout{}\endmodality
// St.S.: It is not unsound but incomplete because we can never prove a property
// about #v0 before it is assigned an initial value...
 variable_declaration_allmodal { \find (\modality{#allmodal}{.. #t #v0 = #vi; ...}\endmodality(post))
                              \replacewith (\modality{#allmodal}{.. #t #v0; #v0 = #vi; ...}\endmodality(post))
                              \heuristics(simplify_prog, simplify_prog_subset)
                              \displayname "variable declaration"};


 multiple_variable_declaration { \find (\modality{#allmodal}{.. #multvardecl ...}\endmodality(post)) 
				\replacewith (\modality{#allmodal}{.. #resolve-multiple-var-decl(#multvardecl); ...}\endmodality(post)) 
				\heuristics(simplify_prog, simplify_prog_subset)};

/////--------------- methods ----------------------------------------------------//
///\rules(nullPointerPolicy:noNullCheck){
///
///  method_call { 
///    \find (\modality{#allmodal}{.. #se.#mn(#selist); ...}\endmodality(post)) 
///    varcond(methodreference #se #mn #selist not static)
///    "Normal Execution":
///      \replacewith (\modality{#allmodal}{.. #method-call(#se.#mn(#selist)); ...}\endmodality(post))
///    \heuristics(simplify_autoname)
///    };
///
///  method_call_with_assignment { 
///    \find (\modality{#allmodal}{.. #lhs = #se.#mn(#selist); ...}\endmodality((post))) 
///    varcond(typeof(#lhs) #v0 new, methodreference #se #mn #selist not static)
///    "Normal Execution":
///      \replacewith (\modality{#allmodal}{.. #typeof(#lhs) #v0;
///	  	                 #method-call(#v0, #se.#mn(#selist));
///		                 #lhs = #v0; 
///                              ...}\endmodality(post))
///    \heuristics(simplify_autoname)
///    \displayname "method_call"
///  };
///
///
///}
///
///\rules {
///
///
///  method_call_eval { 
///    \find (\modality{#allmodal}{.. #nsmr ...}\endmodality(post)) 
///    \replacewith (\modality{#allmodal}{.. #evaluate-arguments(#nsmr); ...}\endmodality(post))
///    \heuristics(simplify_autoname)
///  };
///
///  // may trigger static initialisation, but the super class has either
///  // initialized or during initialisation, but not erroneous. So nothing
///  // happens and we do not need to treat static initialisation here
///  method_call_super { 
///    \find (\modality{#allmodal}{.#ex.. super.#mn(#elist); ...}\endmodality(post)) 
///    \replacewith (\modality{#allmodal}{.. #method-call(#ex, super.#mn(#elist)); 
///                            ...}\endmodality(post)) 
///    \heuristics(simplify_autoname)
///  };
///
///  // may trigger static initialisation, but the super class has either
///  // initialized or during initialisation, but not erroneous. So nothing
///  // happens and we do not need to treat static initialisation here
///  method_call_with_assignment_super {
///    \find (\modality{#allmodal}{.#ex.. #lhs=super.#mn(#elist); ...}\endmodality(post))
///    varcond(typeof(#lhs) #v0 new)
///    \replacewith (\modality{#allmodal}{.. #typeof(#lhs) #v0;
///                               #method-call(#ex, #v0, super.#mn(#elist));
///                               #lhs = #v0;
///                            ...}\endmodality(post)) 
///    \heuristics(simplify_autoname)
///  };
///
///  method_call_with_assignment_eval { 
///    \find (\modality{#allmodal}{.. #lhs = #nsmr; ...}\endmodality(post)) 
///    \replacewith (\modality{#allmodal}{.. #evaluate-arguments(#lhs = #nsmr); ...}\endmodality(post)) 
///    \heuristics(simplify_autoname)
///    \displayname "method_call_eval"
///  };
///
///
///  method_call_empty { 
///    \find (\modality{#allmodal}{.. method-frame(#ex):{} ...}\endmodality(post)) 
///    \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
///    \heuristics(simplify_prog) 
///  };
///
///  method_call_return_void_ignore_trail { 
///     \find (\modality{#allmodal}{.. method-frame(#ex):{return; #slist} ...}\endmodality(post)) 
///     \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
///    \heuristics(simplify_prog) 
///     \displayname "method_call_return_void"
///  };
///
///  method_call_return_ignore_trail { 
///     \find (\modality{#allmodal}{.. method-frame(#v0, #ex):{return #se; #slist} ...}\endmodality(post))
///     \replacewith (\modality{#allmodal}{.. method-frame(#ex):{#v0 = #se;}  ...}\endmodality(post))
///     \heuristics(simplify_prog)
///     \displayname "method_call_return"
///  };
///
///  method_call_return_ignore_result { 
///    \find (\modality{#allmodal}{.. method-frame(#ex):{return #se;} ...}\endmodality(post)) 
///    \replacewith (\modality{#allmodal}{..  ...}\endmodality(post))
///    \heuristics(simplify_prog) 
///  };
///
///  method_body_expand { 	
///    \find (\modality{#allmodal}{.. #mb ...}\endmodality(post))
///    \replacewith (\modality{#allmodal}{.. #expand-method-body(#mb); ...}\endmodality(post))
///    \heuristics(simplify_prog, simplify_prog_subset) 
///  };
///
///  return_in_block_ignore_trail { 
///     \find (\modality{#allmodal}{.. {return; #slist} ...}\endmodality(post)) 
///     \replacewith (\modality{#allmodal}{.. return;  ...}\endmodality(post)) 
///     \heuristics(simplify_prog, simplify_prog_subset) 
///     \displayname "return_in_block"
///  };
///
///  return_in_block_simple_ignore_trail { 
///     \find (\modality{#allmodal}{.. {return #se; #slist} ...}\endmodality(post)) 
///     \replacewith (\modality{#allmodal}{.. return #se;  ...}\endmodality(post)) 
///     \heuristics(simplify_prog, simplify_prog_subset) 
///     \displayname "return_in_block"
///  };
///  
///  method_call_throw_ignore_trail {
///     \find (\modality{#allmodal}{.. method-frame(#ex):{throw #se; #slist} ...}\endmodality(post)) 
///     \replacewith (\modality{#allmodal}{.. throw #se; ...}\endmodality(post))
///     \heuristics(simplify_prog)
///     \displayname "method_call_throw"
///  };
///
///  method_call_throw_with_param_ignore_trail { 
///     \find (\modality{#allmodal}{.. method-frame(#v0, #ex):{throw #se; #slist} 
///                      ...}\endmodality(post)) 
///     \replacewith (\modality{#allmodal}{.. throw #se; ...}\endmodality(post))
///     \heuristics(simplify_prog)
///     \displayname "method_call_throw"
///  };
///
///  throw_in_block_ignore_trail { 
///    \find (\modality{#allmodal}{.. {throw #e; #slist} ...}\endmodality(post))
///    \replacewith (\modality{#allmodal}{.. throw #e;  ...}\endmodality(post))
///    \heuristics(simplify_prog, simplify_prog_subset) 
///    \displayname "throw_in_block"
///  };

//--------------- loops ------------------------------------------------------//

 unwind_while    { \find (\modality{#alltotal}{.. while(#e) #s ...}\endmodality(post))
	           \replacewith (\modality{#alltotal}{.. #unwind-loop (while(#e) #s); ...}\endmodality(post))  
		   \heuristics(loop_expand)};

// BOX  ATTENTION! ONLY FOR DEMO! NOT SOUND FOR ABRUPT TERMINATION!
// while_inv     { \find (==> \[{.. while(#e) #s ...}\]post) varcond(boolean #v new)
//          \replacewith (==> inv );
//          \replacewith (inv ==> \[{.. #s  ...}\] inv);
//          \replacewith (inv, \[{.. #v = #e; ...}\] #v = FALSE ==> 
//           \[{.. #v = #e; ...}\]post )  }; 
 
//--------------- if-statements ----------------------------------------------//

// ODL uses the rule below, but is not allowed to because of
//	// see Bug #0359
//  if_else_split  { \find (==> \modality{#allmodal}{.. if(#e) #s0 else #s1 ...}\endmodality(post))
//       "if true":  \replacewith (==> \modality{#allmodal}{.. #s0 ...}\endmodality(post)) \add (#e ==>);
//       "if false": \replacewith (==> \modality{#allmodal}{.. #s1 ...}\endmodality(post)) \add (!#e ==>)
//       \heuristics(split_if) };
// instead this implementation uses the following set of rules

 /// if_eval {  \find (\modality{#allmodal}{.. if(#nse) #s0 ...}\endmodality(post)) varcond (boolean #boolv new)
 ///    \replacewith (\modality{#allmodal}{.. boolean #boolv; #boolv = #nse; if(#boolv) #s0 ...}\endmodality(post))
 ///    \heuristics(simplify_autoname)
 ///    \displayname "if_eval"
 /// };
 ///
 /// if_else_eval { \find (\modality{#allmodal}{.. if(#nse) #s0 else #s1 ...}\endmodality(post)) 
 ///    varcond (boolean #boolv new)
 ///    \replacewith (\modality{#allmodal}{.. boolean #boolv; #boolv = #nse; if(#boolv) #s0 else{#s1}
 ///                   ...}\endmodality(post) ) 
 ///    \displayname "if_else_eval"
 /// };
 ///
 /// if_eval_h {  \find (\modality{#allmodal}{.. if(#nse) #s0 ...}\endmodality(post)) varcond (boolean #boolv new)
 ///    \replacewith (\modality{#allmodal}{.. boolean #boolv; #boolv = #nse; if(#boolv) #s0 ...}\endmodality(post))
 ///    \heuristics(simplify_autoname) \noninteractive
 ///    \displayname "if_eval"
 /// };
 ///
 /// if_else_eval_h { \find (\modality{#allmodal}{.. if(#nse) #s0 else #s1 ...}\endmodality(post)) 
 ///    varcond (boolean #boolv new)
 ///    \replacewith (\modality{#allmodal}{.. boolean #boolv; #boolv = #nse; if(#boolv) #s0 else{#s1}
 ///                   ...}\endmodality(post) ) 
 ///    \heuristics(simplify_autoname) \noninteractive
 ///    \displayname "if_else_eval"
 /// };

////  if_split_imp  { \find (\modality{#allmodal}{.. if(#e) #s0  ...}\endmodality(post))
////       \replacewith ((#e=TRUE -> \modality{#allmodal}{.. #s0 ...}\endmodality(post))
////		   & (#e=FALSE -> \modality{#allmodal}{.. ...}\endmodality(post))) };
////
////  if_else_split_imp  { \find (\modality{#allmodal}{.. if(#e) #s0 else #s1 ...}\endmodality(post))
////       \replacewith ((#e=TRUE -> \modality{#allmodal}{.. #s0 ...}\endmodality(post))
////		   & (#e=FALSE -> \modality{#allmodal}{.. #s1 ...}\endmodality(post))) };

	// see Bug #0359
 if_split  { \find (==> \modality{#allmodal}{.. if(#se) #s0  ...}\endmodality(post) )
       "if true":  \replacewith (==> \modality{#allmodal}{.. #s0 ...}\endmodality(post)) \add (#se = TRUE ==>);
       "if false": \replacewith (==> \modality{#allmodal}{..  ...}\endmodality(post)) \add (#se = FALSE ==>)  
       \heuristics(split_if) };

  if_else_split_left  { \find ( \modality{#allmodal}{.. if(#se) #s0 else #s1 ...}\endmodality(post) ==>)
       \replacewith ( \modality{#allmodal}{.. #s0 ...}\endmodality(post)==>) \add (#se = TRUE ==>);
       \replacewith ( \modality{#allmodal}{.. #s1 ...}\endmodality(post)==>) \add (#se = FALSE ==>)  \heuristics(split_if) };

 if_split_left  { \find ( \modality{#allmodal}{.. if(#se) #s0  ...}\endmodality(post) ==>)
       \replacewith ( \modality{#allmodal}{.. #s0 ...}\endmodality(post)==>) \add (#se = TRUE ==>);
       \replacewith ( \modality{#allmodal}{..  ...}\endmodality(post)==>) \add (#se = FALSE ==>)  \heuristics(split_if) };

///  if_true   { \assumes ( #se = TRUE ==>)
///       \find (==> \modality{#allmodal}{.. if (#se) #s0 ...}\endmodality(post))
///       \replacewith (==> \modality{#allmodal}{.. #s0 ...}\endmodality(post))  };
///
///
///  if_else_true { \assumes ( #se = TRUE ==>)
///		 \find (==> \modality{#allmodal}{.. if (#se) #s0 else #s1 ...}\endmodality(post))
///                 \replacewith (==> \modality{#allmodal}{.. #s0 ...}\endmodality(post)) };
///
///  if_false   { \assumes ( #se = FALSE ==>)
///       \find (==> \modality{#allmodal}{.. if (#se) #s0 ...}\endmodality(post))        
///       \replacewith (==> \modality{#allmodal}{.. ...}\endmodality(post))  };
///
///  if_else_false { \assumes ( #se = FALSE ==>)
///		 \find (==> \modality{#allmodal}{.. if (#se) #s0 else #s1 ...}\endmodality(post)) 
///                 \replacewith (==> \modality{#allmodal}{.. #s1 ...}\endmodality(post)) };
///
///  if_else_update_true { \find ({#loc:=TRUE}\modality{#allmodal}{.. if (#loc) #s0 else #s1 ...}\endmodality(post))
///                        \replacewith ({#loc:=TRUE}\modality{#allmodal}{.. #s0 ...}\endmodality(post))
///                        \heuristics (simplify_prog)};
///
///  if_else_update_false { \find ({#loc:=FALSE}\modality{#allmodal}{.. if (#loc) #s0 else #s1 ...}\endmodality(post))
///                         \replacewith ({#loc:=FALSE}\modality{#allmodal}{.. #s1 ...}\endmodality(post))
///                         \heuristics (simplify_prog)};
///
///  if_update_true { \find ({#loc:=TRUE}\modality{#allmodal}{.. if (#loc) #s0 ...}\endmodality(post))
///                   \replacewith ({#loc:=TRUE}\modality{#allmodal}{.. #s0 ...}\endmodality(post))
///                   \heuristics (simplify_prog)};
///
///  if_update_false { \find ({#loc:=FALSE}\modality{#allmodal}{.. if (#loc) #s0 ...}\endmodality(post))
///                    \replacewith ({#loc:=FALSE}\modality{#allmodal}{.. ...}\endmodality(post)) 
///                    \heuristics (simplify_prog)};


 empty_block      { \find (\modality{#allmodal}{.. {} ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
	    \heuristics(simplify_prog, simplify_prog_subset)};


 empty_statement  { \find (\modality{#allmodal}{.. ; ...}\endmodality(post))
            \replacewith (\modality{#allmodal}{..  ...}\endmodality(post)) 
	    \heuristics(simplify_prog, simplify_prog_subset)};


/////----------------------------------------------------------------------------
/////-----------                 object creation                      -----------
/////----------------------------------------------------------------------------
///
/// object_creation_assignment { \find (\modality{#allmodal}{.. #lhs = #n;  ...}\endmodality(post)) 
///        varcond(typeof(#n) #v0 new)
///        \replacewith (\modality{#allmodal}{.. #typeof(#v0) #v0 = #create-object(#n); 
///		          #constructor-call(#v0, #n); 
///                          #post-work(#v0, #n);
///			  #lhs = #v0;
///		      ...}\endmodality(post)) 
///	\heuristics(simplify_object_creation)
///	\displayname "object creation"
/// };
///
/// object_creation { \find (\modality{#allmodal}{.. #n ...}\endmodality(post)) 
///        varcond(typeof(#n) #v0 new)
///        \replacewith (\modality{#allmodal}{.. #typeof(#v0) #v0 = #create-object(#n); 
///		          #constructor-call(#v0, #n); 
///                          #post-work(#v0, #n); ...}\endmodality(post)) 
///	\heuristics(simplify_object_creation)
///	\displayname "object creation"
/// };
///
/// special_constructor_call { \find (\modality{#allmodal}{.. #scr ...}\endmodality(post)) 
///        \replacewith (\modality{#allmodal}{.. #special-constructor-call(#scr); ...}\endmodality(post)) 
///	\heuristics(simplify_object_creation)
/// };
///
///  implicit_field_non_null_1{ \find (#se0.#implicitReference = null) 
///			   \replacewith (false) 
///			   \heuristics(simplify, alpha_concrete)
/// };
///
/// implicit_field_non_null_2 { \find (#implicitReference = null) 
///			   \replacewith (false) 
///			   \heuristics(simplify, alpha_concrete)
///			   \displayname "implicit_field_non_null"
/// };
///
/// same_object_base { \find (#se = #se.#next) 
///                    \replacewith (false) 
///                    \heuristics(simplify, alpha_concrete)
/// };
/// same_object_step { \find (#se0.#next = #se1.#next) 
///                    \replacewith (#se0 = #se1) 
///                    \heuristics(simplify, alpha_concrete)
/// };
///
///
///// split_next_to_create { \find (#class.<first> = #class.<first>.<next>) 
/////                      \replacewith (false) };
///
///
/// // reachable_rec_1 { \find ( isReachable(#ref1, #ref2) ) \replacewith (exists n:int.isReachable(#ref1, #ref2, #n)) };
///
/// // reachable_rec_2 { \find ( isReachable(#ref1, #ref2, #n+1) ) \replacewith (isReachable(#ref1.<next>, #ref2, #n)) };
///
/// // reachable_base_true { \find ( isReachable(#ref1, #ref1, 0) ) \replacewith (true) };
///
/// // reachable_base_false { \find ( isReachable(#ref1.<next>, #ref1, #n) ) \replacewith (false) };
///
///
///
/////----------------------------------------------------------------------------
/////-----------                 array creation                      -----------
/////----------------------------------------------------------------------------
///
///
/// array_creation { 
///        \find (\modality{#allmodal}{.. #lhs = #na; ...}\endmodality(post)) 	
///        varcond(typeof(#na) #v0 new)	
///        \replacewith (\modality{#allmodal}{.. 	
///		#typeof(#na) #v0; 
///		#init-array-creation(#v0, #na);
///                #lhs = #v0; ...}\endmodality(post)) 
///	\heuristics(simplify_prog)
/// };
///
/// array_creation_with_initializers { 
///        \find (\modality{#allmodal}{.. #lhs = #arrayinitializer; ...}\endmodality(post)) 	
///        varcond(typeof(#lhs) #v0 new)	
///        \replacewith (\modality{#allmodal}{.. 	
///		#typeof(#lhs) #v0; 
///		#init-array-creation(#v0, #arrayinitializer);
///                #lhs = #v0; ...}\endmodality(post)) 
///	\heuristics(simplify_prog)
/// };
///
/// array_creation_transient1 { 
///        \find (\modality{#allmodal}{.. #lhs = #tboolarray; ...}\endmodality(post)) 	
///        varcond(typeof(#tboolarray) #v0 new)	
///        \replacewith (\modality{#allmodal}{.. 	
///		#typeof(#tboolarray) #v0; 
///		#init-array-creation-transient(#v0, #tboolarray);
///                #lhs = #v0; ...}\endmodality(post)) 
///	\heuristics(simplify_prog)
/// };
///
/// array_creation_transient2 { 
///        \find (\modality{#allmodal}{.. #lhs = #tbytearray; ...}\endmodality(post)) 	
///        varcond(typeof(#tbytearray) #v0 new)	
///        \replacewith (\modality{#allmodal}{.. 	
///		#typeof(#tbytearray) #v0; 
///		#init-array-creation-transient(#v0, #tbytearray);
///                #lhs = #v0; ...}\endmodality(post)) 
///	\heuristics(simplify_prog)
/// };
///
/// array_creation_transient3 { 
///        \find (\modality{#allmodal}{.. #lhs = #tshortarray; ...}\endmodality(post)) 	
///        varcond(typeof(#tshortarray) #v0 new)	
///        \replacewith (\modality{#allmodal}{.. 	
///		#typeof(#tshortarray) #v0; 
///		#init-array-creation-transient(#v0, #tshortarray);
///                #lhs = #v0; ...}\endmodality(post)) 
///	\heuristics(simplify_prog)
/// };
///
/// array_creation_transient4 { 
///        \find (\modality{#allmodal}{.. #lhs = #tobjectarray; ...}\endmodality(post)) 	
///        varcond(typeof(#tobjectarray) #v0 new)	
///        \replacewith (\modality{#allmodal}{.. 	
///		#typeof(#tobjectarray) #v0; 
///		#init-array-creation-transient(#v0, #tobjectarray);
///                #lhs = #v0; ...}\endmodality(post)) 
///	\heuristics(simplify_prog)
/// };
///
///// isTransient
///
/// unfold_istransient { 
///        \find (\modality{#allmodal}{.. #lhs = #istransient; ...}\endmodality(post)) 	
///        varcond(typeof(#istransient) #v0 new)	
///        \replacewith (\modality{#allmodal}{.. 	
///		#typeof(#istransient) #v0; 
///		#process-isTransient(#v0, #istransient);
///                #lhs = #v0; ...}\endmodality(post)) 
///	\heuristics(simplify_prog)
/// };




//----------------------------------------------------------------------------
//-----------                  instanceof 			   -----------
//----------------------------------------------------------------------------

 instanceof_eval { \find (\modality{#allmodal}{.. #v = #nse instanceof #t; ...}\endmodality(post))
	           \varcond(\new(#v0, \typeof(#nse))) 
		   \replacewith ( \modality{#allmodal}{..#typeof(#nse) #v0=#nse; 
				#v=#v0 instanceof #t;...}\endmodality(post) )
	           \heuristics(simplify_autoname)
 };


 instanceof_to_exist_true { \find (G::instance(obj)=TRUE) 
	\varcond (\notFreeIn(x, obj)) 
	\replacewith ((\exists x; obj=x) & !(obj=null) )
	\heuristics(simplify_prog)
 };

 instanceof_to_exist_false { \find (G::instance(obj)=FALSE) 
	\varcond (\notFreeIn(x, obj)) 
	\replacewith (!(\exists x; obj=x) & !(obj=null))
	\heuristics(simplify_prog)
 };

 instance_of_static_eval { \find (G::instance(obj)=TRUE) 
	\replacewith (#staticanalysis(G::instance(obj)=TRUE))
	\heuristics(simplify_instanceof_static)
 };



/////------------------------------------------------------------------------
///// ------------ Rules for comparison operators
/////------------------------------------------------------------------------
///
///  equality_comparision { \find ( \modality{#allmodal}{.. #lhs = #se0 == #se1; ...}\endmodality(post)) 
///    \replacewith ( (! #se0=#se1 ->  \modality{#allmodal}{.. #lhs = false; ...}\endmodality(post)) & 
///                  (#se0=#se1 ->  \modality{#allmodal}{.. #lhs = true; ...}\endmodality(post)))
///    \heuristics(simplify_prog)};
///
///  inequality_comparision { \find ( \modality{#allmodal}{.. #lhs = #se0 != #se1; ...}\endmodality(post)) 
///    \replacewith ( (! #se0=#se1 ->  \modality{#allmodal}{.. #lhs = true; ...}\endmodality(post)) &
///                    (#se0=#se1 ->  \modality{#allmodal}{.. #lhs = false; ...}\endmodality(post))) 
///    \heuristics(simplify_prog)};
///
///  less_than_comparision { \find ( \modality{#allmodal}{.. #lhs = #se0 < #se1; ...}\endmodality(post)) 
///    \replacewith ( (lt(#se0,#se1) ->  \modality{#allmodal}{.. #lhs = true; ...}\endmodality(post) )&
///                  (! lt(#se0,#se1) ->  \modality{#allmodal}{.. #lhs = false; ...}\endmodality(post))) 
///    \heuristics(simplify_prog)};
///
///  less_equal_than_comparision { \find ( \modality{#allmodal}{.. #lhs = #se0 <= #se1; ...}\endmodality(post)) 
///    \replacewith ( ((leq(#se0,#se1)) ->  \modality{#allmodal}{.. #lhs = true; ...}\endmodality(post)) &
///		  (! (leq(#se0,#se1))  ->  \modality{#allmodal}{.. #lhs = false; ...}\endmodality(post))) 
///    \heuristics(simplify_prog)};
///
///  greater_than_comparision { \find ( \modality{#allmodal}{.. #lhs = #se0 > #se1; ...}\endmodality(post)) 
///    \replacewith ( (gt(#se0,#se1) ->  \modality{#allmodal}{.. #lhs = true; ...}\endmodality(post)) &
///                  (! gt(#se0,#se1) ->  \modality{#allmodal}{.. #lhs = false; ...}\endmodality(post))) 
///    \heuristics(simplify_prog)};
///
///  greater_equal_than_comparision { \find ( \modality{#allmodal}{.. #lhs = #se0 >= #se1; ...}\endmodality(post)) 
///    \replacewith ( ((geq(#se0,#se1)) ->  \modality{#allmodal}{.. #lhs = true; ...}\endmodality(post)) &
///		  (! (geq(#se0,#se1))  ->  \modality{#allmodal}{.. #lhs = false; ...}\endmodality(post))) 
///    \heuristics(simplify_prog)};

/////------------------------------------------------------------------------
///// ----------- Rules for handling a cast applied to a compound expression
/////------------------------------------------------------------------------
 ///   (ALSO SEE other casts in deleted javaRules.key)
 /// compound_byte_cast_expression { \find (\modality{#allmodal}{.. #lhs = (byte) #nse; ...}\endmodality(post)) varcond (typeof(#nse) #v new)
 ///           \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v = #nse; #lhs = (byte) #v;  ...}\endmodality(post))
	/// \heuristics (simplify_prog)
 ///        \displayname "cast" };
 ///
 /// compound_short_cast_expression { \find (\modality{#allmodal}{.. #lhs = (short) #nse; ...}\endmodality(post)) varcond (typeof(#nse) #v new)
 ///           \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v = #nse; #lhs = (short) #v;  ...}\endmodality(post)) 
	/// \heuristics (simplify_prog)
 ///        \displayname "cast" };
 ///
 /// compound_int_cast_expression { \find (\modality{#allmodal}{.. #lhs = (int) #nse; ...}\endmodality(post)) varcond (typeof(#nse) #v new)
 ///           \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v = #nse; #lhs = (int) #v;  ...}\endmodality(post)) 
	/// \heuristics (simplify_prog)
 ///        \displayname "cast" };
 ///
 /// compound_long_cast_expression { \find (\modality{#allmodal}{.. #lhs = (long) #nse; ...}\endmodality(post)) varcond (typeof(#nse) #v new)
 ///           \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v = #nse; #lhs = (long) #v;  ...}\endmodality(post)) 
	/// \heuristics (simplify_prog)
 ///        \displayname "cast" };


 elim_double_block { \find (\modality{#allmodal}{{ #slist }}\endmodality(post)) \replacewith (\modality{#allmodal}{ #slist }\endmodality(post)) };

//------------------------------------------------------------------------
// ----------- Rule for removing redundant parentheses
//------------------------------------------------------------------------

  remove_parentheses  { \find (\modality{#allmodal}{.. #lhs = (#e); ...}\endmodality(post)) 
        \replacewith (\modality{#allmodal}{.. #lhs = #e; ...}\endmodality(post)) \heuristics(simplify_prog)};

//------------------------------------------------------------------------ 
// ----------- Rules for binary arithmetic operators applied to at least one compound expression
//------------------------------------------------------------------------

   compound_multiplication_1 { \find (\modality{#allmodal}{.. #lhs=#nse * #se; ...}\endmodality(post))
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v * #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "multiplication"};

   compound_multiplication_2 { \find (\modality{#allmodal}{.. #lhs=#e * #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 * #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "multiplication"};

   compound_division_1 { \find (\modality{#allmodal}{.. #lhs=#nse / #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
        \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v / #se; ...}\endmodality(post)) 
        \heuristics (simplify_prog)
         \displayname "division"};

   compound_division_2 { \find (\modality{#allmodal}{.. #lhs=#e / #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 / #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "division"};

   compound_modulo_1 { \find (\modality{#allmodal}{.. #lhs=#nse % #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v % #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "modulo"};

   compound_modulo_2 { \find (\modality{#allmodal}{.. #lhs=#e % #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 % #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "modulo"};

   compound_addition_1 { \find (\modality{#allmodal}{.. #lhs=#nse + #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v + #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "addition"};

   compound_addition_2 { \find (\modality{#allmodal}{.. #lhs=#e + #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 + #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "addition"};

   compound_subtraction_1 { \find (\modality{#allmodal}{.. #lhs=#nse - #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v - #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "subtraction"};

   compound_subtraction_2 { \find (\modality{#allmodal}{.. #lhs=#e - #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 - #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "subtraction"};

   compound_shiftright_1 { \find (\modality{#allmodal}{.. #lhs=#nse >> #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v >> #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "shift"};

   compound_shiftright_2 { \find (\modality{#allmodal}{.. #lhs=#e >> #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 >> #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "shift"};

   compound_unsigned_shiftright_1 { \find (\modality{#allmodal}{.. #lhs=#nse >>> #se; ...}\endmodality(post)) 
 	\varcond (\new(#v, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v >>> #se; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "shift"};

   compound_unsigned_shiftright_2 { \find (\modality{#allmodal}{.. #lhs=#e >>> #nse; ...}\endmodality(post)) 
         \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
         \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 >>> #v1; ...}\endmodality(post)) 
         \heuristics (simplify_prog)
         \displayname "shift"};

  compound_shiftleft_1 { \find (\modality{#allmodal}{.. #lhs=#nse << #se; ...}\endmodality(post)) 
	\varcond (\new(#v, \typeof(#nse)))
        \replacewith (\modality{#allmodal}{.. #typeof(#nse) #v=#nse; #lhs=#v << #se; ...}\endmodality(post)) 
        \heuristics (simplify_prog)
         \displayname "shift"};

  compound_shiftleft_2 { \find (\modality{#allmodal}{.. #lhs=#e << #nse; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse)))
        \replacewith (\modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse) #v1=#nse; #lhs=#v0 << #v1; ...}\endmodality(post)) 
        \heuristics (simplify_prog)
         \displayname "shift"};

  compound_equality_comparision_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 == #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 == #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "equality"};

  compound_equality_comparision_2 { \find ( \modality{#allmodal}{.. #lhs = #e == #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 == #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "equality"};

  compound_inequality_comparision_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 != #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 != #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "inequality"};

  compound_inequality_comparision_2 { \find ( \modality{#allmodal}{.. #lhs = #e != #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 != #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "inequality"};

  compound_less_than_comparision_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 < #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 < #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "less_than"};

  compound_less_than_comparision_2 { \find ( \modality{#allmodal}{.. #lhs = #e < #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 < #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "less_than"};

  compound_less_equal_than_comparision_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 <= #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 <= #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "less_or_equal"};

  compound_less_equal_than_comparision_2 { \find ( \modality{#allmodal}{.. #lhs = #e <= #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 <= #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "less_or_equal"};

  compound_greater_than_comparision_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 > #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 > #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "greater_than"};

  compound_greater_than_comparision_2 { \find ( \modality{#allmodal}{.. #lhs = #e > #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 > #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "greater_than"};

  compound_greater_equal_than_comparision_1 { \find ( \modality{#allmodal}{.. #lhs = #nse0 >= #se; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#nse0) #v0 = #nse0; #lhs = #v0 >= #se; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "greater_or_equal"};

  compound_greater_equal_than_comparision_2 { \find ( \modality{#allmodal}{.. #lhs = #e >= #nse0; ...}\endmodality(post)) 
        \varcond (\new(#v0, \typeof(#e)), \new(#v1, \typeof(#nse0)))
        \replacewith ( \modality{#allmodal}{.. #typeof(#e) #v0=#e; #typeof(#nse0) #v1 = #nse0; #lhs = #v0 >= #v1; ...}\endmodality(post))
        \heuristics(simplify_prog)
         \displayname "greater_or_equal"};

//------------------------------------------------------------------------
//---------------------- Rules boolean expressions -----------------------
//------------------------------------------------------------------------


  compound_assignment_1 { \find (\modality{#allmodal}{.. #lhs=!#seBool; ...}\endmodality(post)) 
         \replacewith (\modality{#allmodal}{.. if (#seBool) #lhs=false; else #lhs=true; ...}\endmodality(post))
         \heuristics(simplify_expression)
         \displayname "compound_assignment"};  

  compound_assignment_2 { \find (\modality{#allmodal}{.. #lhs=!#nseBool; ...}\endmodality(post))
          \varcond (\new(#v, boolean))
          \replacewith (\modality{#allmodal}{.. boolean #v=#nseBool; #lhs=!#v; ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "compound_assignment"};

   compound_assignment_3 { \find (\modality{#allmodal}{.. #lhs=#exBool0 && #exBool1; ...}\endmodality(post)) 
          \replacewith (\modality{#allmodal}{.. if (!#exBool0) #lhs=false; else #lhs=#exBool1; ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "compound_assignment"};

   compound_assignment_4 { \find (\modality{#allmodal}{.. #lhs=#exBool0 & #exBool1; ...}\endmodality(post))
          \replacewith (\modality{#allmodal}{.. #lhs=#exBool0; 
                            if (!#exBool1) #lhs=false; ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "compound_assignment"};

    compound_assignment_5 { \find (\modality{#allmodal}{.. #lhs=#exBool0 || #exBool1; ...}\endmodality(post)) 
          \replacewith (\modality{#allmodal}{.. if (#exBool0) #lhs=true; else #lhs=#exBool1; ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "compound_assignment"};

   compound_assignment_6 { \find (\modality{#allmodal}{.. #lhs=#exBool0 | #exBool1; ...}\endmodality(post))
          \replacewith (\modality{#allmodal}{.. #lhs=#exBool0;
                            if (#exBool1) #lhs=true; ...}\endmodality(post))
          \heuristics(simplify_expression)
          \displayname "compound_assignment"};

//------------------------------------------------------------------------
// ----------- Rules for array and attribute expressions 
//------------------------------------------------------------------------

///eval_order_array_access1 { 
///		\find (\modality{#allmodal}{..#nv[#e]=#e0;...}\endmodality(post))
///		varcond (typeof(#nv) #v0 new )
///		\replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv;
///				#v0[#e]=#e0;
///					 ...}\endmodality(post)) 
///	         \heuristics(simplify_prog, simplify_prog_subset)
///				\displayname "eval_order_array_access"};
///
///eval_order_array_access2 { 
///		\find (\modality{#allmodal}{..#v[#nse]=#e;...}\endmodality(post))
///		varcond (typeof(#v) #ar1 new, typeof(#nse) #v0 new )
///		\replacewith(\modality{#allmodal}{..#typeof(#v) #ar1 = #v;
///				#typeof(#nse) #v0=#nse;
///				#ar1[#v0]=#e;
///					 ...}\endmodality(post)) 
///	         \heuristics(simplify_prog, simplify_prog_subset)
///				\displayname "eval_order_array_access"};
///
///eval_order_array_access3 { 
///		\find (\modality{#allmodal}{..#v[#se]=#nse;...}\endmodality(post))
///		varcond (typeof(#v) #v0 new, typeof(#nse) #v1 new, typeof(#se) #v2 new )
///		\replacewith(\modality{#allmodal}{..#typeof(#v) #v0=#v;
///				#typeof(#se) #v2=#se;
///				if(#length-reference(#v)<=#se || #se<0 ) throw new java.lang.ArrayIndexOutOfBoundsException();
///				#typeof(#nse) #v1=#nse;
///				#v0[#v2]=#v1; ...}\endmodality(post)) 
///	         \heuristics(simplify_prog, simplify_prog_subset)
///				\displayname "eval_order_array_access"};
///
///
///eval_order_array_access4 { 
///		\find (\modality{#allmodal}{..#v=#nv[#e];...}\endmodality(post))
///		varcond (typeof(#nv) #v0 new)
///		\replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv;
///				#v=#v0[#e];
///					...}\endmodality(post)) 
///	         \heuristics(simplify_prog, simplify_prog_subset)
///				\displayname "eval_order_array_access"};
///
///eval_order_array_access5 { 
///		\find (\modality{#allmodal}{..#v=#v0[#nse];...}\endmodality(post))
///		varcond (typeof(#v0) #ar1 new, typeof(#nse) #v1 new )
///		\replacewith(\modality{#allmodal}{..#typeof(#v0) #ar1 = #v0;
///				#typeof(#nse) #v1=#nse;
///				#v=#ar1[#v1];
///					...}\endmodality(post))
///	         \heuristics(simplify_prog, simplify_prog_subset)
///				\displayname "eval_order_array_access"};
///
///eval_order_array_access6 {
///		\find (\modality{#allmodal}{..#v=#nv.#length; ...}\endmodality(post))
///		varcond(typeof(#nv) #v0 new) 
///		\replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv; #v=#v0.#length; ...}\endmodality(post))
///		\heuristics(simplify_prog, simplify_prog_subset)
///		\displayname "eval_order_array_access"};

///eval_order_access1 {
///		\find (\modality{#allmodal}{..#nv.#a=#e;...}\endmodality(post))
///		varcond(typeof(#nv) #v0 new) 
///		\replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv; #v0.#a=#e;...}\endmodality(post))
///		\heuristics(simplify_prog, simplify_prog_subset)
///		\displayname "eval_order_access"};
///
///eval_order_access2 { 
///		\find (\modality{#allmodal}{.. #v=#nv.#a; ...}\endmodality(post))
///		varcond(typeof(#nv) #v0 new) 
///		\replacewith(\modality{#allmodal}{..#typeof(#nv) #v0=#nv; #v=#v0.#a;...}\endmodality(post))
///		\heuristics(simplify_prog, simplify_prog_subset)
///		\displayname "eval_order_access"};

///eval_order_static_access1 {
///		\find (\modality{#allmodal}{.. #v.#a=#nse; ...}\endmodality(post))
///		varcond(typeof(#v) #v0 new, typeof(#nse) #v1 new, #a static) 
///		\replacewith(\modality{#allmodal}{..
///			    #typeof(#v) #v0=#v;
///			    #typeof(#nse) #v1=#nse;
///			    #v0.#a=#v1;
///		...}\endmodality(post))
///		\heuristics(simplify_prog, simplify_prog_subset)
///		\displayname "eval_order_access"};
///
///eval_order_static_access2  { 
///  \find (\modality{#allmodal}{.. #sv = #v.#a; ...}\endmodality(post)) 
///	varcond(typeof(#a) #v0 new)
///        \replacewith (\modality{#allmodal}{.. 			
///			 #typeof(#a) #v0 = #v.#a;
///			 #sv = #v0;
///        ...}\endmodality(post))
///	\heuristics(simplify_prog, simplify_prog_subset)
///        \displayname "eval_order_access"
///};
///
///eval_order_static_access4  { 
///  \find (\modality{#allmodal}{.. #sv0 = #sv1; ...}\endmodality(post)) 
///	varcond(typeof(#sv1) #v0 new)
///        \replacewith (\modality{#allmodal}{.. 			
///			 #typeof(#sv1) #v0 = #sv1;
///			 #sv0 = #v0;
///        ...}\endmodality(post))
///	\heuristics(simplify_prog, simplify_prog_subset)
///        \displayname "eval_order_access"
///};
///
///eval_order_static_access5  {
///  \find (\modality{#allmodal}{.. #sv0 = #sv1.#a; ...}\endmodality(post))
///      varcond(typeof(#sv1) #v0 new)
///        \replacewith (\modality{#allmodal}{..
///                       #typeof(#sv1) #v0 = #sv1.#a;
///                       #sv0 = #v0;
///        ...}\endmodality(post))
///      \heuristics(simplify_prog, simplify_prog_subset)
///      \displayname "eval_order_access"
///};

}

\rules(programRules:ODL) {
///eval_order_access3{
///		\find (\modality{#allmodal}{.. #v.#a=#nse; ...}\endmodality(post))
///		varcond(#a not static, typeof(#v) #v0 new, typeof(#nse) #v1 new) 
///		\replacewith(\modality{#allmodal}{..
///			   #typeof(#v) #v0=#v;
///			   #typeof(#nse) #v1=#nse;
///			   #v0.#a=#v1;...}\endmodality(post))
///		\heuristics(simplify_prog, simplify_prog_subset)
///		\displayname "eval_order_access"};


//////assignment_array1{\find (\modality{#normalassign}{..#v[#se]=#se0;...}\endmodality(post))
//////		 "Normal Execution":
//////			\replacewith(( lt(#se,#lengthReference(#v)) & lt(-1,#se)) ->   
//////			{#v[#se]:=#se0}\modality{#normalassign}{.. ...}\endmodality(post)) ;
//////		 "Index Out of Bounds":
//////			\replacewith((leq(#lengthReference(#v), #se) | !lt(-1,#se)) -> 
//////			  \modality{#normalassign}{..
//////			    throw new java.lang.ArrayIndexOutOfBoundsException();
//////		          ...}\endmodality(post))
//////	         \heuristics(simplify_prog, simplify_prog_subset)
//////		 \displayname "assignment"};
//////		    
//////assignment_array2{\find (\modality{#normalassign}{..#v = #v0[#se];...}\endmodality(post))
//////		"Normal Execution":
//////		   \replacewith(( lt(#se,#lengthReference(#v0)) & lt(-1,#se)) ->   
//////		     {#v:=#v0[#se]}\modality{#normalassign}{.. ...}\endmodality(post));  
//////		"Index Out of Bounds":
//////	  	   \replacewith((!(#v0=null) & (leq(#lengthReference(#v0), #se) | !lt(-1,#se))) -> \modality{#normalassign}{..
//////			throw new java.lang.ArrayIndexOutOfBoundsException();
//////		    ...}\endmodality(post))
//////    	         \heuristics(simplify_prog, simplify_prog_subset)
//////		 \displayname "assignment"};



///assignment_read_attribute{
///		\find (\modality{#normalassign}{..#v0 = #v.#a;...}\endmodality(post))
///		varcond(#a not static)
///		"Normal Execution":
///		      \replacewith( {#v0 := #v.#a}\modality{#normalassign}{.. ...}\endmodality(post))
///		 \heuristics(simplify_prog, simplify_prog_subset)
///		\displayname "assignment"};
///
///assignment_write_attribute {
///		\find (\modality{#normalassign}{..#v.#a=#se;...}\endmodality(post))
///	        varcond(#a not static)
///		"Normal Execution":
///		      \replacewith( {#v.#a := #se}\modality{#normalassign}{.. ...}\endmodality(post))
///		\heuristics(simplify_prog, simplify_prog_subset)
///		\displayname "assignment"
///};


		    
//------------------------------------------------------------------------
// ----------- Rules for modal tautologies
//------------------------------------------------------------------------

box_true{ \find (\[{.. #s ...}\]true)
	  \replacewith(true)
	  \heuristics(modal_tautology)};

diamond_false{ \find (\<{.. #s ...}\>false)
	       \replacewith(false)
	       \heuristics(modal_tautology)};

diamond_and_left{\find (\<{.. #s ...}\>(post & post1)==>)
		 \replacewith(\<{.. #s ...}\>post & \<{.. #s ...}\>post1==>)};

box_and_left{\find (\[{.. #s ...}\](post & post1) ==>)
		 \replacewith(\[{.. #s ...}\]post & \[{.. #s ...}\]post1==>)};

diamond_and_right{\find (==> \<{.. #s ...}\>(post & post1))
		 \replacewith(==> \<{.. #s ...}\>post);
		 \replacewith(==> \<{.. #s ...}\>post1)};

box_and_right{\find (==> \[{.. #s ...}\](post & post1))
		 \replacewith(==> \[{.. #s ...}\]post);  
		 \replacewith(==> \[{.. #s ...}\]post1)};

diamond_or_right{\find (==> \<{.. #s ...}\>(post | post1))
		 \replacewith(==> \<{.. #s ...}\>post | \<{.. #s ...}\>post1)};

box_or_right{\find (==> \[{.. #s ...}\](post | post1))
	     \replacewith(==> \[{.. #s ...}\]post | \[{.. #s ...}\]post1)};

diamond_or_left{\find (\<{.. #s ...}\>(post | post1)==>)
		 \replacewith(\<{.. #s ...}\>post | \<{.. #s ...}\>post1==>)};

box_or_left{\find (\[{.. #s ...}\](post | post1)==>)
	     \replacewith(\[{.. #s ...}\]post | \[{.. #s ...}\]post1==>)};

same_diamonds_right{ \assumes (==>\<{#s}\>post) 
		    \find (==> \<{#s}\>post1)
		    \add (==> \<{#s}\>(post | post1))};

same_diamonds_left{ \assumes (\<{.. #s ...}\>post ==>)
		    \find (\<{.. #s ...}\>post1 ==>)
		    \add (\<{.. #s ...}\>(post & post1) ==>)};

same_boxes_right{ \assumes (==>\[{.. #s ...}\]post)
		    \find (==> \[{.. #s ...}\]post1)
		    \add (==> \[{.. #s ...}\](post | post1))};

same_boxes_left{ \assumes (\[{.. #s ...}\]post ==>)
		    \find (\[{.. #s ...}\]post1 ==>)
		    \add (\[{.. #s ...}\](post & post1) ==>)};

box2diamond{\find (\[{.. #s ...}\]post)
	    \replacewith(!\<{.. #s ...}\>!post)};

diamond2box{\find (\<{.. #s ...}\>post)
	    \replacewith(!\[{.. #s ...}\]!post)};


}


//==========================================================================//
//================ assignment rules, for passive accesses ==================//
//==== hint: one-to-one correspondence with section for enabled static ====//
//==========               initialisation rules                  ===========//
//==========================================================================//
///rules/*(initialisation:disableStaticInitialisation)*/ {
///
///  //-------------------------------------------------------//
///  //------------ rules for static write access ------------//
///  //-------- without prefix or with type prefix -----------//
///  //------ insert for allnormal, throughout, traonly ------//
///  //-------------------------------------------------------//
///
///  assignment_write_static_attribute {
///	\find (\modality{#normalassign}{.. #sv = #se; ...}\endmodality(post))	
///	\replacewith({#sv := #se}\modality{#normalassign}{.. ...}\endmodality(post))
///        \heuristics(simplify_prog, simplify_prog_subset)
///        \displayname "assignment"
///  };
///
///
///  //-------------------------------------------------------//
///  //------------ rules for static read access -------------//
///  //-------- without prefix or with type prefix -----------//
///  //------ insert for allnormal, throughout, traonly ------//
///  //-------------------------------------------------------//
///  assignment_read_static_attribute {
///	\find (\modality{#normalassign}{.. #loc = #sv; ...}\endmodality(post))
///        \replacewith({#loc := #sv}\modality{#normalassign}{.. ...}\endmodality(post))
///        \heuristics(simplify_prog, simplify_prog_subset)
///        \displayname "assignment"
///  }  ;
///
///  //----------------------------------------------------//
///  //------------ rules for static write access ---------//
///  //-------------      with var prefix       -----------//
///  //----- insert for allnormal, throughout, traonly ----//
///  //----------------------------------------------------//
///  assignment_write_static_attribute_with_variable_prefix {
///	\find (\modality{#normalassign}{.. #v.#a = #se; ...}\endmodality(post))
///	varcond(#a static)
///	\replacewith({#v.#a := #se} \modality{#normalassign}{.. ...}\endmodality(post))
///        \heuristics(simplify_prog, simplify_prog_subset)
///        \displayname "active_attribute_access"
///  };
///
///  //----------------------------------------------------//
///  //------------ rules for static read access ----------//
///  //-------------      with var prefix       -----------//
///  //----- insert for allnormal, throughout, traonly ----//
///  //----------------------------------------------------//
///  assignment_read_static_attribute_with_variable_prefix {
///	\find (\modality{#normalassign}{.. #loc = #v.#a; ...}\endmodality(post))
///	varcond(#a static)
///        \replacewith({#loc := #v.#a}\modality{#normalassign}{.. ...}\endmodality(post))
///        \displayname "assignment"
///  };
///
///}

//=====================================================================//
//======================= static method calls    ======================//
//=====================================================================//

///rules/*(initialisation:disableStaticInitialisation)*/ {
///  static_method_call { 
///    \find (\modality{#allmodal}{.. #se.#mn(#elist); ...}\endmodality(post)) 
///    varcond(methodreference #se #mn #elist static)
///    "Normal Execution":
///    \replacewith (\modality{#allmodal}{.. 			    
///		 #method-call(#v0, #se.#mn(#elist));
///		...}\endmodality(post))
///    \heuristics(simplify_autoname)
///    \displayname "method_call"
///  };
///
///  static_method_call_with_assignment { 
///    \find (\modality{#allmodal}{.. #lhs = #se.#mn(#elist); ...}\endmodality(post)) 
///    varcond(typeof(#lhs) #v0 new, methodreference #se #mn #elist static)
///    "Normal Execution":
///      \replacewith (\modality{#allmodal}{.. 
///			    #typeof(#lhs) #v0;
///	  	            #method-call(#v0, #se.#mn(#elist));
///		            #lhs = #v0; 
///                  ...}\endmodality(post))
///    \heuristics(simplify_autoname)
///    \displayname "method_call"
///  };
///
///  static_method_call_static_via_typereference { 
///    \find (\modality{#allmodal}{.. #t.#mn(#elist); ...}\endmodality(post)) 
///    \replacewith (\modality{#allmodal}{..  #method-call(#t.#mn(#elist)); ...}\endmodality(post)) 
///    \heuristics(simplify_autoname)
///    \displayname "method_call"
///  };
///
///
///  static_method_call_static_with_assignment_via_typereference {
///    \find (\modality{#allmodal}{.. #lhs = #t.#mn(#elist); ...}\endmodality(post))
///    varcond(typeof(#lhs) #v0 new)
///    \replacewith (\modality{#allmodal}{..  #typeof(#lhs) #v0;
///			        #method-call(#v0, #t.#mn(#elist));
///			        #lhs = #v0; ...}\endmodality(post)) 
///    \heuristics(simplify_autoname)
///    \displayname "method_call"
///  };
///
///  method_call_with_assignment_within_class {
///    \find (\modality{#allmodal}{.#ex.. #lhs=#mn(#elist); ...}\endmodality(post)) 
///    varcond(typeof(#lhs) #v0 new)
///    \replacewith (\modality{#allmodal}{.. #typeof(#lhs) #v0;
///                               #method-call(#ex, #v0, #mn(#elist));
///                               #lhs = #v0;
///                            ...}\endmodality(post)) 
///    \heuristics(simplify_autoname)
///    \displayname "method_call"
///  };
///
///  method_call_within_class { 
///    \find (\modality{#allmodal}{.. #mn(#elist); ...}\endmodality(post)) 
///    \replacewith (\modality{#allmodal}{.. 
///	#method-call(#mn(#elist)); ...}\endmodality(post)) 
///    \heuristics(simplify_autoname)
///    \displayname "method_call"
///  };   
///}
